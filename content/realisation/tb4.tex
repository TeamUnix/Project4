\section{Time box 4}
\listoftodos
\subsection{Time box planning}
\begin{figure}[H]
	\begin{centering}
		\missingfigure{Updated timebox figure}
		%\includegraphics[width=1.0\textwidth]{images/tb_r3.pdf}
		%\caption{Updated time-box}
	\end{centering}
\end{figure}
\subsubsection{Work to be done in this time box}
\begin{itemize}
	\item Power line communication module
	\begin{itemize}
		\item EMC test of modules
	\end{itemize}
	\item Database
	\begin{itemize}
		\item \todo[author=Jesus, inline]{edit what you like and bake a cake}
	\end{itemize}
	\item Physical interface
	\begin{itemize}
		\item Wishbone slave interface
		\item Switch driver
		\item LED driver
	\end{itemize}
\end{itemize}
\paragraph{Description:}
\begin{description}
	\item[Power line module] \todo[author=Dennis, inline]{edit here Dennis}
	\item[Database] \todo[author=Jesus, inline]{edit here Jesus}
	\item[Physical interface] is the light indication and the switches that shall be on the physical hub interface
\end{description}
\subsubsection{Time planning}
\begin{table}[H]
\centering
	\begin{tabular}{|l|c|c|c|c|}
		\hline
		~			& PLC module	& Database	& Physical interface\\ \hline
		Estimation	& xx			& 10		& 12				\\
		Actual		& xx			& xx		& xx				\\
		Developer	& Dennis		& Paulo		& Theis				\\
		\hline
	\end{tabular}
	\caption{Estimation and actual time used on the project}
\end{table}
\subsection{Power line communication module - Dennis}
%			intro
%			
%					verification specification
%					deployment specification
%					
%			Analysis
%	
%	                Refactored block diagram
%	                Refactored class diagram
%	                Detailed use cases
%	                User interface specification
%	                System interface specification
%	                Dimensioning specification 
%	
%	        Design
%	
%	                UML/SysML deployment view(s)
%	                Mechanical specifications and dimensioning
%	                HW module specification per block
%	                UML SW deployment view
%	                Class specification
%	                Refactored class diagram
%	                Use case scenarios specifications
%	                Sequence diagrams 
%	
%	        Implementation
%	
%	                Mechanical drawings with details explained
%	                Electronic diagrams with details explained
%	                Source code with details explained
%	                Description of integration 
%	
%	        Verification
%	
%	                Module tests
%	                Integration tests
%	                Acceptance test
\subsection{Database - Paulo}
%		Intro

Each module of the system has sensors and data to be stored and shown to the user. As such, data have to be stored in a convenient and consistent way. A SQL database ( MySQL) is used. All data stored have to be present in a web interface the integration between this type of data base and a server-side scripting ( PHP ) keeps the development faster and completely open source.
A database have to be consistent, flexible and efficient so no data is lost or repeated when a value is send to it.
%
%			Verification specification
\subsubsection{Verification specification}
A LAMP ( Linux Apache MySQL PHP ) web server is implemented at the development environment used to build the uClinux image. This use a linux distribution Centos virtual machine in which the web server was built ( how to build the web server explanation further in this documentation ).
For an easy and fast verification and development of the database a phpMyAdmin web application was installed at the server.
The verifications can be found at the end of this section.

%			Deployment specification
\subsubsection{Deployment specification}
\missingfigure{Have no idea what this should be}

%		Analysis
%	
%	                Refactored block diagram
%	                Refactored class diagram
%	                Detailed use cases
%	                User interface specification
%	                System interface specification
%	                Dimensioning specification 
\subsubsection{Analysis}
To develop a database, data models are generated from the requirements and system information analysis, this is an abstract way of presenting the data to be stored.
\paragraph{Requirements}
	\begin{itemize}
		\item Jan is looking at the web interface for the energy hub. From where he can see the status for each modules connected to it
in a graphically way.
		\item A new energy module is connected to the hub, Jan opens the web interface for the energy hub, he logs in the administrator section of the system
to start, stop or see a more detailed overview of each module.
		\item Jan arrives at the university in the morning and an email was send to him reporting a failure in the green energy system, he login to the administrator web interface, and he can see what the problem might be, and if it's possible to solve it directly on the interface.
	\end{itemize}

From this requirements given by the customer the relevant information for the database development is filtered:
	\begin{itemize}
		\item The status of each module have to be show.
		\item A detailed overview of each module such as current production (Voltage, Current, Power, etc.), efficiency of the module, etc.
		\item Errors have to be reported to the system administrator / maintainer.
	\end{itemize}
	
In a deeper analysis of the information system for the power energy hub, some technical data is needed to be stored such as:
	\begin{itemize}
		\item Each module have is unique id, this is similar to the MAC address, this way when a module is connected is possible to check if the module have been connected before, so the data can be stored for the same module instead of instantiate a new module which can generate ambiguous data.
		\item Three types of modules are defined: input, output and bidirectional. This are seen from the power hub point of view where inputs are producers ( solar panels, wind turbine, ... ), output are consumers ( Inverter, 30V output socket ) and bidirectional ( C.A.E.S, batteries, ...).
	\end{itemize}

%	        Design
%	
%	                UML/SysML deployment view(s)
%	                Mechanical specifications and dimensioning
%	                HW module specification per block
%	                UML SW deployment view
%	                Class specification
%	                Refactored class diagram
%	                Use case scenarios specifications
%	                Sequence diagrams 
%	
\subsubsection{Design}

\paragraph{Data sets}

From the system information analysis a basic tabular structure is designed for a better understanding and overview of the data, this is called data set structure.
\\\\
TYPE(ID\_TYPE, TYPE);

\begin{table}[H]
\centering
	\begin{tabular}{| p{2cm} | p{10cm} |}
		\hline
		ID\_TYPE & Auto increment integer, a new id number is generated when a different type is needed to the system. \\\hline
		TYPE & Describe the type name for example: Input, output, bidirectional, etc.\\\hline
	\end{tabular}
\end{table}

STATUS(ID\_STATUS, STATUS);

\begin{table}[H]
\centering
	\begin{tabular}{| p{2cm} | p{10cm} |}
		\hline
		ID\_STATUS & Auto increment integer, a new id number is generated when a different status is needed to the system. \\\hline
		STATUS & Describe the status name for example: Running, stopped, warning, etc.\\\hline
	\end{tabular}
\end{table}


MODULES(ID\_MODULE, UNIQUE\_ID, ID\_TYPE, ID\_STATUS, NAME);

\begin{table}[H]
\centering
	\begin{tabular}{| p{2cm} | p{10cm} |}
		\hline
		ID\_MODULE & Auto increment integer, a new id number is generated every time an unknown module is connected. \\\hline
		UNIQUE\_ID & Module unique ID, this id as primary key ensures that no module with is repeated in the database.\\\hline
		ID\_TYPE & This is a foreigner key for the table type, this way if some other type of module is needed it can be dynamical add. \\\hline
		ID\_STATUS & This is a foreigner key for the table status, this way if some other status to the module is needed it can be dynamical add. \\\hline
		NAME & The name of the module for example, Solar Panel, wind turbine, battery. \\\hline
	\end{tabular}
\end{table}
As a requirement the database have to store the measurement  from different modules, the common and minimal measurements needed from the modules are current and voltage. So a log data set is created.
\\\\
LOGS(ID\_LOG, ID\_MODULE, DATE\_TIME, PORT, CURRENT, VOLTAGE);

\begin{table}[H]
\centering
	\begin{tabular}{| p{2cm} | p{10cm} |}
		\hline
		ID\_LOG & Auto increment integer, a new id number is generated every time an measurement is add. \\\hline
		ID\_MODULE & This is a foreigner key for the table modules, this allow the system to know from which module correspond the measurement .\\\hline
		DATE\_TIME & Date and time of the measurement is saved so it can be plotted or in case of a lower efficiency a detailed history can analysed. \\\hline
		PORT & Defines in which port or the energy hub the module is connected in the time of the measurement. \\\hline
		CURRENT & Current measurement. \\\hline
		VOLTAGE & Voltage measurement. \\\hline
	\end{tabular}
\end{table}

At this point the database can initialise a new module or identified if the module where connected before, change the status for each module and add new measurements for each module. ( Verification 1, 2 and 3 )

Measurements are add to the database every \todo{Time between measurements}, which in a non-stop system database size could be a problem, to avoid this situation a wrapper data set is created. This will store an average of values between a time span for each module, allowing the customer either to erase the values from the log or export them out from the database. Crucial data can be lost in this step for example the port history in case of troubleshooting, and precise date and time which would not allow the precise plot of data. 

WRAPPER(ID\_WRAP, ID\_MODULE, DATE\_FROM, DATE\_TO, AVG\_CURRENT, AVG\_VOLTAGE);

\begin{table}[H]
\centering
	\begin{tabular}{| p{2cm} | p{10cm} |}
		\hline
		ID\_WRAP & Auto increment integer, a new id number is generated every time an wrap is needed. \\\hline
		ID\_MODULE & This is a foreigner key for the table modules, this allow the system to know from which module correspond the values .\\\hline
		DATE\_FROM & Date and time of the time span start. \\\hline
		DATE\_TO & Date and time of the time span end. \\\hline
		AVG\_CURRENT & Average current measurements. \\\hline
		AVG\_VOLTAGE & Average voltage measurements. \\\hline
	\end{tabular}
\end{table}

The system is now able to decrease the amount of space needed using a time span and average values. ( Verification 4 )

During the verification process some problems related to the flexibility of the database were found:
	\begin{itemize}
		\item Problem 1: The Photovoltaic and Wind Turbine modules have more measurements to be stored then only current and voltage, for example velocity and direction of the wind, sun position, etc.
		\item \todo{Meeting with martin anytime this week to talk about the database structure}
	\end{itemize}

\paragraph{Problem 1}
In the design of this database it was assumed that all the modules would only save to the database the current and voltage. But during the verification process, the designed database was not flexible enough by the type of measurements being restrict to only current and voltage.

	\begin{itemize}
		\item How to make the database more flexible so it would allow inserting different measurements for different modules?
	\end{itemize}

Different approaches were made:
	
	\begin{itemize}
		\item Option 1: Create a new table for each new module that have extra measurements and add the ID\_EXTRA to the logs table.
		\item Option 2: Give different unique ids to the sensors and relate them to their modules, so the log will store the sensor measurement.
	\end{itemize}

Option 1 was not consistent since that every time a new module was connected a new table had to be created for that module with the needed measurement units.\\\\
Option 2 is the most reliable and the implemented one. A table Units and Sensors were created:\\
\\
SENSOR(ID\_SENSOR, ID\_MODULE, ID\_UNITS);

\begin{table}[H]
\centering
	\begin{tabular}{| p{2cm} | p{10cm} |}
		\hline
		ID\_SENSOR & Auto increment integer, a new id number is generated when a different sensor is needed to the system. \\\hline
		ID\_MODULE & This is a foreigner key for the table sensors, this allow the system to know from which module correspond the sensor, being a primary key with the id\_sensor, this way each sensor correspond to only one module .\\\hline
		ID\_UNITS & This is a foreigner key for the table units, this allow the system to know which units the sensor is measuring.\\\hline
	\end{tabular}
\end{table}

UNITS(ID\_UNIT, UNIT);

\begin{table}[H]
\centering
	\begin{tabular}{| p{2cm} | p{10cm} |}
		\hline
		ID\_UNIT & Auto increment integer, a new id number is generated when a different unit is needed to the system. \\\hline
		UNIT & Describe the unit name for example: A, V, deg ,m/s,etc. (Ampere, Volt, Degrees, Velocity)\\\hline
	\end{tabular}
\end{table}

In table wrapper and logs the ID\_MODULE was replaced with ID\_SENSOR. The database becomes more flexible since at anytime a module with new unknown sensors can be add and a sensor can be added to a existent module and the values will always be saved and retrieved to the user with the appropriat measurement units.

\paragraph{Data Model}


\begin{figure}[H]
	\begin{centering}
		%\missingfigure{Updated timebox figure}
		\includegraphics[width=1.0\textwidth]{images/db_structure.pdf}
		\caption{Data Model}
	\end{centering}
\end{figure}


%	        Implementation
%	
%	                Mechanical drawings with details explained
%	                Electronic diagrams with details explained
%	                Source code with details explained
%	                Description of integration 
%	
\subsubsection{Implementation}

%	        Verification
%	
%	                Module tests
%	                Integration tests
%	                Acceptance test
\subsubsection{Verification}
\begin{table}[H]
\centering
	\begin{tabular}{| c | l | c |}
		\hline
		Verification & Description & Acceptance \\\hline
		1 & Initialise a new module or identified if the module where connected before & ~ \\\hline
		2 & Change the status for each module & ~ \\\hline
		3 & Add new measurements for each module & ~ \\\hline
		4 & Decrease the database size using a time span and average values. & ~ \\\hline
		2 & Change the status for each module & ~ \\\hline
		2 & Change the status for each module & ~ \\\hline
		2 & Change the status for each module & ~ \\\hline
		2 & Change the status for each module & ~ \\\hline
		2 & Change the status for each module & ~ \\\hline
	\end{tabular}
\end{table}

\subsection{Physical interface - Theis}
The interface shall be made to fulfil the requirements \textit{NF-1.5}\footnote{Requirement is found in table 3.2 in EPRO 3 project energy-hub} and \textit{B-1.2}\footnote{Requirement is found in table 3.4 in EPRO 3 project energy-hub}.\\
\begin{table}[H]
\centering
	\begin{tabular}{|p{1.2cm}|p{2.3cm}|p{6cm}|p{6cm}|}
	\hline
	ID		& Requirement	& Description															& Comments\\\hline
	NF-1.5	& HW Interface	& 1 start button for the hub. 10 buttons to each start a module.		& This is shown with 8 switches on the Spartan 6 board\\\hline
	B-1.2	& Physical		& 1 diode showing when a module is off and one showing when it is on.	& This is shown with 8 LEDs on the Spartan 6 board\\\hline
	\end{tabular}
\end{table}

\subsubsection{Analysis}
The physical interface is where the user interact directly with the hub, it is placed on the hub cabinet. It shall be possible for the user to start the hub and modules. There shall also be an indication of the hub and module status.\\
For turning on module there shall be a switch for each module and one for turning on the hub. To indicate the status there shall be a LED for every module and one to indicate the hub status.\\
The interface is made on the Spartan6 and is communicating with the ARM7 through the external memory controller in the ARM7 and using a wishbone interface on the Spartan6.
\begin{figure}[H]
	\begin{centering}
		%\missingfigure{Updated timebox figure}
		\includegraphics[width=1.0\textwidth]{images/analysis_phy_interface.png}
		\caption{User-system interface interaction}
	\end{centering}
\end{figure}
\subsubsection{Design}
The physical interface is made with 8 switches and 8 LEDs, and is controlled through the Spartan 6. The block diagram below shows how the interface is made inside the Spartan 6, with the wishbone interface to the master, the master wishbone is discussed in Time box 3 section 3.5.3.
\begin{figure}[H]
	\begin{centering}
			%\missingfigure{Updated timebox figure}
			\includegraphics[width=0.7\textwidth]{images/Design_HWmodule.png}
			\caption{Block diagram for the interface in the Spartan 6}
	\end{centering}
\end{figure}
\subsubsection{Implementation}
The implementation is made in the Spartan 6 board. There is 8 LEDs and 8 switches on board, that is used for the interface. The blocks is written in VHDL.
\paragraph{LED interface}
The LEDs is controlled with the LED block in the Spartan 6, and it is able to send and receive data with a wishbone interface. The data output is the status of the 8 LEDs, the data input is used to turn on and off the LEDs.\\\\
In the code below, the entity of the LED controller is shown, the wishbone interface is defined from line 5 to line 16, these lines is common for all wishbone slaves. In line 19 the output for the 8 LEDs is defined as a 8 bit vector.
\begin{lstlisting}[language=VHDL]
...
entity WBS_leds is
	port	(
			--! Wishbone Slave interface
			--Input
			clk_i			: in		std_logic;		--! Clock input from SYSCON
			rst_i			: in		std_logic;		--! Reset for Wishbone interface
			cyc_i			: in		std_logic;		--! cycle input, asserted when cycle is in progress
			stb_i			: in		std_logic;		--! Strobe input, similar to Chip Select
			we_i			: in		std_logic;		--! Write Enable: High=WR, Low=RD
			dat_i			: in		wb_dat_typ;		--! data from host
			adr_i			: in		wb_lad_typ;		--! Low address input
			--Ouput
			ack_o			: out		std_logic;		--! Slave acknowledge output, asserted after sucessful cycle
			err_o			: out		std_logic;		--! Error output, abnormal cycle termination
			rty_o			: out		std_logic;		--! Retry output, slave not ready
			dat_o			: out		wb_dat_typ;		--! data to host
			---------------------------------
			--! Output port
			leds			: out		std_logic_vector(7 downto 0)
			);
end WBS_leds;
...
\end{lstlisting}
Here the slave is responding the master, the error and retry signal is not supported in this slave, they are assigned with zeros, the acknowledge bit is set high if the strobe and cycle is assigned by the master. The Q signal is assigned to the LEDs and the data output. If the master reads data, it will get the status of the LEDs.
\begin{lstlisting}[language=VHDL]
...
	signal Q				: std_logic_vector(7 downto 0);

begin

--  Concurrent assignments
--	Wishbone cycle acknowledge
	err_o <= '0';	--error signal
	rty_o <= '0';	--retry signal
	ack_o <= stb_i and cyc_i;  --! asynchronous cycle termination is OK here.
--	Data
	dat_o(7 downto 0) <= Q;
	leds <= Q;
...
\end{lstlisting}
In the code below the writing to the LEDs is made. If the cycle, strobe and the write enable inputs is high, the master wants to write data to this slave, then the process checks the address that the slave is sending data to. To write data to the LEDs the address has to be five zeros, then the code will assign Q with the data input from the master.
\begin{lstlisting}[language=VHDL]
...
--!  Processes                                             --
--! Wishbone write to Q register
	Reg : process(clk_i)
		begin
			if(clk_i'event and clk_i = '1') then
				if (rst_i = '1') then
					Q <= Revision_c(7 downto 0);          --! Revision readable at reset 
				else
					if ((cyc_i and stb_i and we_i) = '1') then
						case adr_i is
							when A_WBO_REG1 =>
								Q	<= dat_i(7 downto 0);
							when others =>
							--Ack_o <= '0'; 
						end case;
						
					else
						Q <= Q;
					end if;
				end if;
			end if;
	end process Reg;
...
\end{lstlisting}
\paragraph{Switch interface}
The switches is read from the switches block through wishbone interface in the Spartan 6. This block is read only, and the data output is the status of the 8 switches.\\\\
The wishbone part of the code i common to the entity code in the LED block. For the switches an input vector is made with 8 bit.
\begin{lstlisting}[language=VHDL]
...
entity WBS_switches is
	port	(
			--! Wishbone Slave interface
			--Input
			clk_i			: in		std_logic;		--! Clock input from SYSCON
			rst_i			: in		std_logic;		--! Reset for Wishbone interface
			cyc_i			: in		std_logic;		--! cycle input, asserted when cycle is in progress
			stb_i			: in		std_logic;		--! Strobe input, similar to Chip Select
			we_i			: in		std_logic;		--! Write Enable: High=WR, Low=RD
			dat_i			: in		wb_dat_typ;		--! data from host
			adr_i			: in		wb_lad_typ;		--! Low address input
			--Ouput
			ack_o			: out		std_logic;		--! Slave acknowledge output, asserted after sucessful cycle
			err_o			: out		std_logic;		--! Error output, abnormal cycle termination
			rty_o			: out		std_logic;		--! Retry output, slave not ready
			dat_o			: out		wb_dat_typ;		--! data to host
			-------------------------------------------------
			--! Intput port
			sw				:in			std_logic_vector(7 downto 0)
			);
end WBS_switches;
...
\end{lstlisting}
The acknowledge bit for the master is set here with the high strobe and cycle input.
\begin{lstlisting}[language=VHDL]
...
--  Concurrent assignments
--	Wishbone cycle acknowledge
	err_o <= '0';	--error signal
	rty_o <= '0';	--retry signal
	ack_o <= stb_i and cyc_i;  --! asynhronous cycle termination is OK here.
...
\end{lstlisting}
In the code below, the switches status is written to the master wishbone. The process write the switches status to the lowest 8 bit in the data string and fill the rest with zeros, if the cycle and strobe input are high and the write enable is low to indicate that the master wants to read data.
\begin{lstlisting}[language=VHDL]
...
--!  Processes                                             --
	Reg : process(clk_i)
		begin
			if(clk_i'event and clk_i = '1') then
				if (rst_i = '1') then
					dat_o <= Revision_c;          --! Revision readable at reset
				else
					if ((cyc_i and stb_i and not we_i) = '1') then
						case adr_i is
							when A_WBO_REG1 =>
								dat_o(7 downto 0)	<= sw;
								dat_o(15 downto 8)	<= (others => '0');
							when others =>
							--Ack_o <= '0'; 
						end case;
						
					else
						dat_o <= dat_o;
					end if;
				end if;
			end if;
	end process Reg;
...
\end{lstlisting}
The rest of the code is made by Morten Opprud Jakobsen, and is not in the scope of this section.
\subsubsection{Verification}
The verification is made on the computer by simulating a test bench for writing to the LEDs and reading from the switches, and a test program on the ARM7 is made, to read the switches and write the status to the LEDs. The test with the ARM7 was recorded and is available through this link \url{http://www.youtube.com/watch?v=3MUK6qbg0Rk}
\paragraph{Read switches}
In the start of the test, \textit{reset} is active and the switch status is set. before a read cycle is assigned the \textit{address} is assigned, then the \textit{chip select} goes low, then \textit{read (output enable)}. The test shows that the data is tri-stated until the \textit{read} goes low, and one clock cycle after, the status on \textit{switch} is loaded into \textit{data}.
\begin{figure}[H]
	\begin{centering}
		%\missingfigure{Updated timebox figure}
		\includegraphics[width=1.0\textwidth]{images/tb_wb_read.png}
		\caption{Test bench simulation of read}
	\end{centering}
\end{figure}
\paragraph{Write to LEDs}
In the write test, \textit{leds} is uninitialized and \textit{reset} is active, before a write cycle is assigned the \textit{address} and \textit{data} is assigned, then the \textit{chip select} goes low, then \textit{write (write enable)}. The test show that one clock cycle after \textit{write} goes low the \textit{data} is loaded onto the \textit{Leds}.
\begin{figure}[H]
	\begin{centering}
		%\missingfigure{Updated timebox figure}
		\includegraphics[width=1.0\textwidth]{images/tb_wb_write.png}
		\caption{Test bench simulation of write}
	\end{centering}
\end{figure}
\subsubsection{Conclusion}
The test verify that the implementation of the interface design is working properly. The switches block is not completely finished, right now to register changes in the switches the ARM7 shall read the status to often, to prevent this an interrupt function is to be implemented, in that way the ARM7 is only reading the status when the switches changes. The interrupt function is not on the scope of this time box.
\subsection{Deployment}
%			Customers signature for acceptance 